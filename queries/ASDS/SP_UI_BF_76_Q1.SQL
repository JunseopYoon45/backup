CREATE OR REPLACE PROCEDURE DWSCM."SP_UI_BF_76_Q1" (
	  p_VER_CD         VARCHAR2
    , p_ITEM_LV        VARCHAR2 := NULL -- id 로 넘어옴 
    , p_ITEM_CD        VARCHAR2 := NULL
    , p_SALES_LV       VARCHAR2 := NULL
    , p_SALES_CD       VARCHAR2 := NULL
    , p_SRC_TP         VARCHAR2  
    , p_SUM            VARCHAR2 := 'Y'     
    , pRESULT          OUT SYS_REFCURSOR
)IS 
  /**************************************************************************
   * Copyrightⓒ2023 ZIONEX, All rights reserved.
   **************************************************************************
   * Name : SP_UI_BF_76_Q1
   * Purpose : 예측정확도(등급별) 조회
   * Notes :      
   *    - 예측 시작일부터 실적이 존재하는 일자까지 정확도 조회
   *    - 소분류 이상부터 조회
   * 	M20180115092445697M411878346346N	ITEM_ALL	상품전체
   *	N20180115092528519N506441512113N	LEVEL1		대분류
   *	N20180115092559329M499525073971N	LEVEL2		중분류
   *	FA5FEBBCADDED90DE053DD0A10AC8DB5	LEVEL3		소분류
   *	N20180115092712856O251735022591O	ALL			채널전체
   *	FE00001E54F88F3FE053DD0A10AC762B	CENTER		센터
   *	N20180115092710840N520475678180O	CHANNEL		채널선택
   **************************************************************************/
/*
DECLARE
    pRESULT SYS_REFCURSOR;
BEGIN
    DWSCM.SP_UI_BF_76_Q1('BF-20230828-01', 'FA5FEBBCADDED90DE053DD0A10AC8DB5', 'AC01', 'N20180115092710840N520475678180O', '', 'KR', 'Y', pRESULT);
    DWSCM.SP_UI_BF_76_Q1('BF-20230828-01', 'FA5FEBBCADDED90DE053DD0A10AC8DB5', 'AC01', 'FE00001E54F88F3FE053DD0A10AC762B', '01', 'FR', 'Y', pRESULT);
    DBMS_SQL.RETURN_RESULT(pRESULT);
END;
 */
    v_EXISTS_NUM    INT :=0;
    p_FROM_DATE     DATE := NULL;
    p_TO_DATE     	DATE := NULL;
    v_SRC_TP        VARCHAR2(10) := NVL(p_SRC_TP, '');

BEGIN

    SELECT MAX(TARGET_FROM_DATE)
      INTO p_FROM_DATE
      FROM TB_BF_CONTROL_BOARD_VER_DTL 
     WHERE VER_CD = p_VER_CD;
    
    SELECT TRUNC(SYSDATE, 'IW') - 7 INTO p_TO_DATE FROM DUAL;
    

    SELECT CASE WHEN EXISTS (SELECT 1 FROM TB_CM_ITEM_LEVEL_MGMT WHERE LV_MGMT_ID = p_ITEM_LV) THEN 1 ELSE 0 END INTO v_EXISTS_NUM
    FROM DUAL;
	   	
   	IF p_SUM = 'N'
   	THEN
   	OPEN pRESULT FOR  
    WITH IDS AS (
	    SELECT IH.DESCENDANT_ID AS DESC_ID
	         , IH.DESCENDANT_CD AS DESC_CD
	         , IH.DESCENDANT_NM AS DESC_NM
	         , IH.ANCESTER_CD   AS ANCS_CD
	         , IL.ITEM_LV_NM    AS ANCS_NM
	         , IM.ATTR_03		AS SRC_TP
	         , IM.ATTR_06		AS GRADE
	      FROM TB_DPD_ITEM_HIER_CLOSURE IH
	     INNER JOIN TB_CM_ITEM_LEVEL_MGMT IL 
	        ON IH.ANCESTER_ID = IL.ID
	     INNER JOIN TB_CM_ITEM_MST IM 
	        ON IH.DESCENDANT_CD = IM.ITEM_CD
	     WHERE 1=1
	       AND IL.LV_MGMT_ID = p_ITEM_LV
	       AND IH.LEAF_YN = 'Y'
	       AND IM.ATTR_03 LIKE v_SRC_TP||'%'
	       AND ANCESTER_CD = p_ITEM_CD
	    )
	, ADS AS (
	    SELECT SH.DESCENDANT_ID AS DESC_ID
	         , SH.DESCENDANT_CD AS DESC_CD
	         , SH.DESCENDANT_NM AS DESC_NM
	         , SH.ANCESTER_CD   AS ANCS_CD
	         , SL.SALES_LV_NM   AS ANCS_NM
	      FROM TB_DPD_SALES_HIER_CLOSURE SH
	     INNER JOIN TB_DP_SALES_LEVEL_MGMT SL 
	        ON SH.ANCESTER_ID = SL.ID 
	     WHERE 1=1
	       AND SL.LV_MGMT_ID = p_SALES_LV
	       AND SH.LEAF_YN = 'Y' 
	       AND ANCESTER_CD LIKE ''||'%'  
	     UNION ALL
	    SELECT SH.DESCENDANT_ID AS DESC_ID
	         , SH.DESCENDANT_CD AS DESC_CD
	         , SH.DESCENDANT_NM AS DESC_NM
	         , SH.ANCESTER_CD   AS ANCS_CD
	         , AM.ACCOUNT_NM    AS ANCS_NM
	      FROM TB_DPD_SALES_HIER_CLOSURE SH
	     INNER JOIN TB_DP_ACCOUNT_MST AM 
	        ON SH.ANCESTER_ID = AM.ID
	     WHERE 1=1
	       AND SH.LEAF_YN = 'Y'
	       AND 1 = CASE WHEN EXISTS (SELECT 1 FROM TB_DP_SALES_LEVEL_MGMT WHERE LV_MGMT_ID = p_SALES_LV) THEN 0 ELSE 1 END
	       AND ANCESTER_CD LIKE ''||'%'  
	)
	, RT AS (
		SELECT I.ANCS_CD AS ITEM_LV_CD
			 , I.ANCS_NM AS ITEM_LV_NM
			 , SRC_TP
			 , I.DESC_CD AS ITEM_CD
			 , A.DESC_CD AS ACCOUNT_CD
			 , A.DESC_NM AS ACCOUNT_NM
			 , BASE_DATE
			 , GRADE
			 , NVL(QTY_ADJ, QTY) AS QTY 
		  FROM TB_BF_RT_FINAL_ADJ RT
		 INNER JOIN IDS I
		   ON RT.ITEM_CD = I.DESC_CD
		 INNER JOIN ADS A 
		   ON RT.ACCOUNT_CD = A.DESC_CD
		 WHERE VER_CD = p_VER_CD
		  AND BASE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE	  	 
	) 
	, SA AS (
		SELECT I.DESC_CD AS ITEM_CD
			 , A.DESC_CD AS ACCOUNT_CD
			 , BASE_DATE
			 , QTY
		  FROM TB_CM_ACTUAL_SALES_FCST SA
		 INNER JOIN IDS I
		    ON SA.ITEM_MST_ID = I.DESC_ID
		 INNER JOIN ADS A
		    ON SA.ACCOUNT_ID = A.DESC_ID	 
		 WHERE VER_CD = p_VER_CD
 		   AND BASE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE
	) 
	, AGG AS (
		SELECT ITEM_LV_CD
			 , ITEM_LV_NM
			 , SRC_TP
			 , ACCOUNT_CD
			 , ACCOUNT_NM
			 , GRADE
			 , ROUND(AVG(WAPE), 2) AS WAPE
		  FROM (SELECT ITEM_LV_CD
					 , ITEM_LV_NM
					 , SRC_TP
					 , ITEM_CD
					 , ACCOUNT_CD
					 , ACCOUNT_NM
					 , GRADE
					 , CASE WHEN SUM(ERR) = 0 THEN 100 
			         		ELSE (CASE WHEN (1-SUM(ERR)/SUM(ACT_SALES)) >= 0 THEN (1-SUM(ERR)/SUM(ACT_SALES))*100
			         				   ELSE 0 END) END WAPE
			      FROM (SELECT RT.ITEM_LV_CD
							 , RT.ITEM_LV_NM
							 , RT.SRC_TP
							 , RT.ITEM_CD
							 , RT.ACCOUNT_CD
							 , RT.ACCOUNT_NM
							 , GRADE
							 , ABS(RT.QTY - NVL(SA.QTY, 0)) AS ERR
							 , NVL(SA.QTY, 0) + 0.00001 AS ACT_SALES
						  FROM RT 
						  LEFT JOIN SA 
						    ON RT.ITEM_CD = SA.ITEM_CD
						   AND RT.ACCOUNT_CD = SA.ACCOUNT_CD
						   AND RT.BASE_DATE = SA.BASE_DATE)
				   GROUP BY ITEM_LV_CD, ITEM_LV_NM, SRC_TP, ITEM_CD, ACCOUNT_CD, ACCOUNT_NM, GRADE)
	 	  GROUP BY ITEM_LV_CD, ITEM_LV_NM, SRC_TP, ACCOUNT_CD, ACCOUNT_NM, GRADE
	) 
	, TOTAL_AGG AS (
		SELECT ITEM_LV_CD
			 , CASE WHEN SRC_TP = 'KR' THEN '국내'
			 		WHEN SRC_TP = 'FR' THEN '수입' END AS SRC_TP
			 , ACCOUNT_CD
			 , ROUND(AVG(WAPE), 2) AS WAPE
		  FROM AGG	 
		 GROUP BY ITEM_LV_CD, SRC_TP, ACCOUNT_CD
	) 
	SELECT A.SRC_TP
		 , A.ITEM_LV_NM
		 , A.ACCOUNT_NM
		 , 기본
		 , 필수
		 , 선택1
		 , 선택2
		 , 구색
		 , 신상품
		 , 시리즈
		 , 시즌
		 , 등급없음
		 , B.WAPE AS 총계
	FROM (SELECT CASE WHEN SRC_TP = 'KR' THEN '국내'
				   	  WHEN SRC_TP = 'FR' THEN '수입' END AS SRC_TP		
			   , ITEM_LV_CD
			   , ITEM_LV_NM
			   , ACCOUNT_CD
			   , ACCOUNT_NM
			   , GRADE
			   , WAPE
		    FROM AGG)
		PIVOT ( AVG(WAPE) FOR GRADE IN ('BAS' AS 기본, 'NCS' AS 필수, 'SL1' AS 선택1, 'SL2' AS 선택2,
										'ASS' AS 구색, 'NEW' AS 신상품 , 'SRZ' AS 시리즈, 'SES' AS 시즌, NULL AS 등급없음)) A
	 INNER JOIN TOTAL_AGG B 
	   ON A.SRC_TP = B.SRC_TP
	  AND A.ITEM_LV_CD = B.ITEM_LV_CD
	  AND A.ACCOUNT_CD = B.ACCOUNT_CD
	ORDER BY 1, 3;

    ELSIF P_SUM = 'Y'
    THEN 
    OPEN pRESULT FOR
    WITH IDS AS (
	    SELECT IH.DESCENDANT_ID AS DESC_ID
	         , IH.DESCENDANT_CD AS DESC_CD
	         , IH.DESCENDANT_NM AS DESC_NM
	         , IH.ANCESTER_CD   AS ANCS_CD
	         , IL.ITEM_LV_NM    AS ANCS_NM
	         , IM.ATTR_03		AS SRC_TP
	         , IM.ATTR_06		AS GRADE
	      FROM TB_DPD_ITEM_HIER_CLOSURE IH
	     INNER JOIN TB_CM_ITEM_LEVEL_MGMT IL 
	        ON IH.ANCESTER_ID = IL.ID
	     INNER JOIN TB_CM_ITEM_MST IM 
	        ON IH.DESCENDANT_CD = IM.ITEM_CD
	     WHERE 1=1
	       AND IL.LV_MGMT_ID = p_ITEM_LV
	       AND IH.LEAF_YN = 'Y'
	       AND IM.ATTR_03 LIKE v_SRC_TP||'%'
	       AND ANCESTER_CD = p_ITEM_CD
	    )
	, ADS AS (
	    SELECT SH.DESCENDANT_ID AS DESC_ID
	         , SH.DESCENDANT_CD AS DESC_CD
	         , SH.DESCENDANT_NM AS DESC_NM
	         , SH.ANCESTER_CD   AS ANCS_CD
	         , SL.SALES_LV_NM   AS ANCS_NM
	      FROM TB_DPD_SALES_HIER_CLOSURE SH
	     INNER JOIN TB_DP_SALES_LEVEL_MGMT SL 
	        ON SH.ANCESTER_ID = SL.ID 
	     WHERE 1=1
	       AND SL.LV_MGMT_ID = p_SALES_LV
	       AND SH.LEAF_YN = 'Y' 
	       AND ANCESTER_CD LIKE p_SALES_CD||'%'  
	     UNION ALL
	    SELECT SH.DESCENDANT_ID AS DESC_ID
	         , SH.DESCENDANT_CD AS DESC_CD
	         , SH.DESCENDANT_NM AS DESC_NM
	         , SH.ANCESTER_CD   AS ANCS_CD
	         , AM.ACCOUNT_NM    AS ANCS_NM
	      FROM TB_DPD_SALES_HIER_CLOSURE SH
	     INNER JOIN TB_DP_ACCOUNT_MST AM 
	        ON SH.ANCESTER_ID = AM.ID
	     WHERE 1=1
	       AND SH.LEAF_YN = 'Y'
	       AND 1 = CASE WHEN EXISTS (SELECT 1 FROM TB_DP_SALES_LEVEL_MGMT WHERE LV_MGMT_ID = p_SALES_LV) THEN 0 ELSE 1 END
	       AND ANCESTER_CD LIKE p_SALES_CD||'%'  
	)
	, RT AS (
		SELECT I.ANCS_CD AS ITEM_LV_CD
			 , I.ANCS_NM AS ITEM_LV_NM
			 , SRC_TP
			 , I.DESC_CD AS ITEM_CD
			 , A.ANCS_CD AS ACCOUNT_CD
			 , A.ANCS_NM AS ACCOUNT_NM
			 , BASE_DATE
			 , GRADE
			 , SUM(NVL(QTY_ADJ, QTY)) AS QTY 
		  FROM TB_BF_RT_FINAL_ADJ RT
		 INNER JOIN IDS I
		   ON RT.ITEM_CD = I.DESC_CD
		 INNER JOIN ADS A 
		   ON RT.ACCOUNT_CD = A.DESC_CD
		 WHERE VER_CD = p_VER_CD
		  AND BASE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE	  	 
		 GROUP BY I.ANCS_CD, I.ANCS_NM, SRC_TP, I.DESC_CD, A.ANCS_CD, A.ANCS_NM, BASE_DATE, GRADE
	) 
	, SA AS (
		SELECT I.DESC_CD AS ITEM_CD
			 , A.ANCS_CD AS ACCOUNT_CD
			 , BASE_DATE
			 , SUM(QTY) AS QTY
		  FROM TB_CM_ACTUAL_SALES_FCST SA
		 INNER JOIN IDS I
		    ON SA.ITEM_MST_ID = I.DESC_ID
		 INNER JOIN ADS A
		    ON SA.ACCOUNT_ID = A.DESC_ID	 
		 WHERE VER_CD = p_VER_CD
 		   AND BASE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE
 		 GROUP BY I.DESC_CD, A.ANCS_CD, BASE_DATE
	) 
	, AGG AS (
		SELECT ITEM_LV_CD
			 , ITEM_LV_NM
			 , SRC_TP
			 , ACCOUNT_CD
			 , ACCOUNT_NM
			 , GRADE
			 , ROUND(AVG(WAPE), 2) AS WAPE
		  FROM (SELECT ITEM_LV_CD
					 , ITEM_LV_NM
					 , SRC_TP
					 , ITEM_CD
					 , ACCOUNT_CD
					 , ACCOUNT_NM
					 , GRADE
					 , CASE WHEN SUM(ERR) = 0 THEN 100 
			         		ELSE (CASE WHEN (1-SUM(ERR)/SUM(ACT_SALES)) >= 0 THEN (1-SUM(ERR)/SUM(ACT_SALES))*100
			         				   ELSE 0 END) END WAPE
			      FROM (SELECT RT.ITEM_LV_CD
							 , RT.ITEM_LV_NM
--							 , RT.SRC_TP
							 , CASE WHEN v_SRC_TP IS NULL THEN '전체'
							 		ELSE RT.SRC_TP END AS SRC_TP
							 , RT.ITEM_CD
							 , RT.ACCOUNT_CD
							 , RT.ACCOUNT_NM
							 , RT.GRADE
							 , ABS(RT.QTY - NVL(SA.QTY, 0)) AS ERR
							 , NVL(SA.QTY, 0) + 0.00001 AS ACT_SALES
						  FROM RT 
						  LEFT JOIN SA 
						    ON RT.ITEM_CD = SA.ITEM_CD
						   AND RT.ACCOUNT_CD = SA.ACCOUNT_CD
						   AND RT.BASE_DATE = SA.BASE_DATE)
					   GROUP BY ITEM_LV_CD, ITEM_LV_NM, SRC_TP, ITEM_CD, ACCOUNT_CD, ACCOUNT_NM, GRADE)
	 	  GROUP BY ITEM_LV_CD, ITEM_LV_NM, SRC_TP, ACCOUNT_CD, ACCOUNT_NM, GRADE
	) 
	, CNT AS (
		SELECT A.ITEM_LV_CD
			 , A.ACCOUNT_CD
			 , CASE WHEN A.SRC_TP = 'KR' THEN '국내'
			 		WHEN A.SRC_TP = 'FR' THEN '수입'
			 		ELSE '전체' END AS SRC_TP	
			 , BAS_C
			 , NCS_C
			 , SL1_C
			 , SL2_C
			 , ASS_C
			 , NEW_C
			 , SRZ_C
			 , SES_C
			 , NULL_C
			 , TOTAL_C
		  FROM (SELECT ITEM_LV_CD
		  			 , ACCOUNT_CD
		  			 , SRC_TP
		  			 , GRADE
		  			 , COUNT(*) AS CNT
		  		  FROM (SELECT DISTINCT ITEM_CD
				  			 , ITEM_LV_CD
							 , ACCOUNT_CD
--							 , SRC_TP
							 , CASE WHEN v_SRC_TP IS NULL THEN '전체'
							 		ELSE SRC_TP END AS SRC_TP
							 , GRADE
						  FROM RT)
				 GROUP BY ITEM_LV_CD, ACCOUNT_CD, SRC_TP, GRADE)
		  PIVOT ( AVG(CNT) FOR GRADE IN  ('BAS' AS BAS_C, 'NCS' AS NCS_C, 'SL1' AS SL1_C, 'SL2' AS SL2_C,	
										  'ASS' AS ASS_C, 'NEW' AS NEW_C, 'SRZ' AS SRZ_C, 'SES' AS SES_C, NULL AS NULL_C)) A
	 	INNER JOIN (SELECT ITEM_LV_CD
			  			 , ACCOUNT_CD
			  			 , SRC_TP
			  			 , COUNT(*) AS TOTAL_C
			  		  FROM (SELECT DISTINCT ITEM_CD
					  			 , ITEM_LV_CD
								 , ACCOUNT_CD
--								 , SRC_TP
								 , CASE WHEN v_SRC_TP IS NULL THEN '전체'
							 			ELSE SRC_TP END AS SRC_TP
							  FROM RT)
					 GROUP BY ITEM_LV_CD, ACCOUNT_CD, SRC_TP) B
	       ON A.ITEM_LV_CD = B.ITEM_LV_CD
	      AND A.ACCOUNT_CD = B.ACCOUNT_CD
	      AND NVL(A.SRC_TP, 0) = NVL(B.SRC_TP, 0)
	)
	, TOTAL_AGG AS (
		SELECT ITEM_LV_CD
			 , CASE WHEN SRC_TP = 'KR' THEN '국내'
			 		WHEN SRC_TP = 'FR' THEN '수입' 
			 		ELSE '전체' END AS SRC_TP			 		
			 , ACCOUNT_CD
			 , ROUND(AVG(WAPE), 2) AS WAPE
		  FROM AGG	 
		 GROUP BY ITEM_LV_CD, SRC_TP, ACCOUNT_CD
	) 
	SELECT A.SRC_TP
		 , A.ITEM_LV_NM
		 , A.ACCOUNT_NM
		 , CASE WHEN BAS IS NULL THEN NULL
		 		ELSE BAS||'%('||BAS_C||'개)' END AS 기본
		 , CASE WHEN NCS IS NULL THEN NULL
		 		ELSE NCS||'%('||NCS_C||'개)' END AS 필수
		 , CASE WHEN SL1 IS NULL THEN NULL
		 		ELSE SL1||'%('||SL1_C||'개)' END AS 선택1
		 , CASE WHEN SL2 IS NULL THEN NULL
		 		ELSE SL2||'%('||SL2_C||'개)' END AS 선택2
		 , CASE WHEN ASS IS NULL THEN NULL
		 		ELSE ASS||'%('||ASS_C||'개)' END AS 구색
		 , CASE WHEN NEW IS NULL THEN NULL
		 		ELSE NEW||'%('||NEW_C||'개)' END AS 신상품
		 , CASE WHEN SRZ IS NULL THEN NULL
		 		ELSE SRZ||'%('||SRZ_C||'개)' END AS 시리즈
		 , CASE WHEN SES IS NULL THEN NULL
			    ELSE SES||'%('||SES_C||'개)' END AS 시즌
		 , CASE WHEN "NULL" IS NULL THEN NULL
		 		ELSE "NULL"||'%('||NULL_C||'개)' END AS 등급없음
		 , B.WAPE||'%('||TOTAL_C||'개)' AS 총계
	  FROM (SELECT CASE WHEN SRC_TP = 'KR' THEN '국내'
			 			WHEN SRC_TP = 'FR' THEN '수입' 
			 			ELSE '전체' END AS SRC_TP
				 , ITEM_LV_CD
				 , ITEM_LV_NM
				 , ACCOUNT_CD
				 , ACCOUNT_NM
				 , GRADE
				 , WAPE
			  FROM AGG)
			 PIVOT ( AVG(WAPE) FOR GRADE IN ('BAS' AS BAS, 'NCS' AS NCS, 'SL1' AS SL1, 'SL2' AS SL2,
											 'ASS' AS ASS, 'NEW' AS NEW , 'SRZ' AS SRZ, 'SES' AS SES, 'NULL' AS "NULL")) A
	 INNER JOIN TOTAL_AGG B 
	    ON NVL(A.SRC_TP, 0) = NVL(B.SRC_TP, 0)
	   AND A.ITEM_LV_CD = B.ITEM_LV_CD
	   AND A.ACCOUNT_CD = B.ACCOUNT_CD
	 INNER JOIN CNT C
	    ON A.ITEM_LV_CD = C.ITEM_LV_CD
	   AND A.ACCOUNT_CD = C.ACCOUNT_CD
	   AND NVL(A.SRC_TP, 0) = NVL(C.SRC_TP, 0)
	 ORDER BY 1, 4;    
    END IF;
   
   
END;