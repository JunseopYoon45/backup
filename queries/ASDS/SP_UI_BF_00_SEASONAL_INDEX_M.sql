CREATE OR REPLACE PROCEDURE DWSCM."SP_UI_BF_00_SEASONAL_INDEX_M"
(
	p_VER_CD 				VARCHAR2
  , P_RT_ROLLBACK_FLAG	OUT VARCHAR2   
  , P_RT_MSG			OUT VARCHAR2
)
IS
  /**************************************************************************
   * Copyrightⓒ2023 ZIONEX, All rights reserved.
   **************************************************************************
   * Name : SP_UI_BF_00_SEASONAL_INDEX_M
   * Purpose : 월간 품목 시즌지수 생성
   * Notes :
   **************************************************************************/
	p_INPUT_FROM_DATE 	DATE;
	p_INPUT_TO_DATE 	DATE;
	p_TARGET_TO_DATE 	DATE;
	p_WEAK VARCHAR2(20);
	p_STRONG VARCHAR2(20);
	a VARCHAR2(20);
	b VARCHAR2(200);
	c VARCHAR2(50);

BEGIN
	/* 시즌지수 산정 기간 선정 */
	SELECT ADD_MONTHS(TRUNC(MAX(INPUT_FROM_DATE),'MM'), 1)
		 , MAX(INPUT_TO_DATE)
		 , TRUNC(ADD_MONTHS(MAX(TARGET_FROM_DATE), 6), 'IW')
		 INTO
		   p_INPUT_FROM_DATE
		 , p_INPUT_TO_DATE
		 , p_TARGET_TO_DATE
	  FROM TB_BF_CONTROL_BOARD_VER_DTL
	  WHERE VER_CD = p_VER_CD;
	 
	SELECT ATTR_01 INTO p_WEAK
	  FROM TB_CM_COMM_CONFIG
	 WHERE CONF_CD = 'WEAK';
	
	SELECT ATTR_01 INTO p_STRONG
	  FROM TB_CM_COMM_CONFIG
	 WHERE CONF_CD = 'STRONG'; 	 
	 
 	/* 기존 버전 시즌지수 삭제 */	
	DELETE FROM TB_BF_SEASONAL_INDEX_M
	 WHERE VER_CD = p_VER_CD;
	
	INSERT INTO TB_BF_SEASONAL_INDEX_M 
	/* 시즌지수 생성 기간 선정 */
	WITH CAL AS (
		SELECT MIN(DAT) AS FROM_DATE
	         , MAX(DAT) AS TO_DATE
	         , MIN(YYYY) AS YYYY
	         , MIN(MM) AS MM
	         , COUNT(DAT) AS DAT_CNT
		  FROM TB_CM_CALENDAR	
	     WHERE DAT BETWEEN p_INPUT_FROM_DATE AND p_TARGET_TO_DATE
		 GROUP BY YYYY, MM, TO_CHAR(DP_WK)
	) 
	/* 시즌지수 산정 대상 선정*/
	, TGT AS (
		SELECT DISTINCT ITEM_CD
		  FROM TB_BF_RT_FINAL_M
		 WHERE VER_CD = p_VER_CD
--		   AND REGEXP_INSTR(ITEM_CD,'[^0-9]') = 0
	)
	/* 시즌지수 실적 선정(예측에 사용된 실적) */
	, SA AS (
    	SELECT TRUNC(CAL.FROM_DATE, 'MM') AS BASE_DATE
    		 , CAL.YYYY AS YEAR
    		 , CAL.MM
    		 , SA.ITEM_CD
    	     , SUM(ROUND(SA.QTY * CAL.DAT_CNT / (SA.TO_DATE-SA.FROM_DATE+1)))  AS QTY
	 	  FROM (
		 	  	SELECT BASE_DATE 	 AS FROM_DATE
				     , BASE_DATE + 6 AS TO_DATE
				     , IH.ANCESTER_CD AS ITEM_CD
				     , SUM(QTY) AS QTY
				  FROM TB_CM_ACTUAL_SALES SA
				 INNER JOIN TB_DPD_ITEM_HIER_CLOSURE IH ON SA.ITEM_MST_ID = IH.ANCESTER_ID
				 INNER JOIN TGT ON IH.ANCESTER_CD = TGT.ITEM_CD
				 INNER JOIN CAL ON SA.BASE_DATE BETWEEN CAL.FROM_DATE AND CAL.TO_DATE
				 WHERE BASE_DATE BETWEEN p_INPUT_FROM_DATE AND p_INPUT_TO_DATE
				 GROUP BY BASE_DATE, IH.ANCESTER_CD
				) SA
	 	  LEFT JOIN CAL ON CAL.FROM_DATE BETWEEN SA.FROM_DATE AND SA.TO_DATE
	 	 WHERE TRUNC(CAL.FROM_DATE, 'MM') < TO_DATE(SUBSTR(p_VER_CD, 5, 8))
	 	 GROUP BY TRUNC(CAL.FROM_DATE, 'MM'), CAL.YYYY, CAL.MM, SA.ITEM_CD
	) 
	/* 시즌지수 예측값 선정(미래 예측값 6개월) */
	, RT AS (
    	SELECT BASE_DATE
			 , CAL.YYYY AS YEAR
			 , CAL.MM
			 , RT.ITEM_CD
			 , SUM(QTY) AS QTY
		  FROM TB_BF_RT_FINAL_M RT
		 INNER JOIN CAL ON RT.BASE_DATE = CAL.FROM_DATE
		 WHERE VER_CD = p_VER_CD
		   AND BASE_DATE <= p_TARGET_TO_DATE
		 GROUP BY BASE_DATE, CAL.YYYY, CAL.MM, RT.ITEM_CD
	) 
	/* 과거 실적 + 미래 예측값 */
	, AGG AS (
		SELECT * FROM SA 
		UNION ALL
		SELECT * FROM RT
	) 
	/* 연도/월별 평균 */
	, AGG_M AS (
		SELECT MM
			 , YEAR
			 , ITEM_CD
			 , SUM(QTY) AS QTY
	 	 FROM AGG
	 	 GROUP BY MM, YEAR, ITEM_CD
	) 
	/* SES1용 월별 평균*/   -- 변경 부분
	, MM_AVG AS (
		SELECT MM, ITEM_CD, MM_AVG, SUM(MM_AVG) OVER(PARTITION BY ITEM_CD) AS SUM_MM_AVG
		  FROM (
				SELECT MM, ITEM_CD, AVG(QTY) AS MM_AVG
				  FROM AGG_M
				 GROUP BY MM, ITEM_CD
			   )
	)	
	/* 연도별 평균 */
	, YR_AVG AS (
		SELECT ITEM_CD
			 , YEAR
			 , AVG(QTY) AS YR_AVG
	    FROM AGG_M
	   GROUP BY ITEM_CD, YEAR
	) 
	/* 연도/월별 실적 */
	, MY AS (
		SELECT A.ITEM_CD
			 , A.YEAR
			 , MM
			 , CASE WHEN YR_AVG = 0 THEN 0 ELSE QTY / YR_AVG END MY_QTY
		FROM AGG_M A 
		INNER JOIN YR_AVG B ON A.ITEM_CD = B.ITEM_CD AND A.YEAR = B.YEAR
	)
	/* 월별 평균 */
	, MY_AVG AS (
		SELECT ITEM_CD
			 , MM
			 , AVG(MY_QTY) AS MY_AVG
		FROM MY
		GROUP BY ITEM_CD, MM
	) 
	/* 월별 시스템 시즌지수 생성 */
	, SES_1 AS (
		SELECT ITEM_CD
			 , MM
			 , CASE WHEN SUM_MM_AVG = 0 THEN 0
			 		ELSE MM_AVG/SUM_MM_AVG END AS SES1  -- 변경 부분
			 , CASE WHEN SUM_MM_AVG = 0 THEN 0
				 	WHEN ROUND(MM_AVG/SUM_MM_AVG, 4) >= p_WEAK THEN 1 
				 	ELSE 0 END OVER_WEAK  -- 변경 부분
			 , CASE WHEN MM BETWEEN 1 AND 3 THEN 'Q1' 
				    WHEN MM BETWEEN 4 AND 6 THEN 'Q2'
				    WHEN MM BETWEEN 7 AND 9 THEN 'Q3'
				    ELSE 'Q4' END QUARTER
		  FROM MM_AVG  -- 변경 부분
	) 
	, MY_SUM AS (
		SELECT ITEM_CD, SUM(MY_AVG) AS MY_SUM
		FROM MY_AVG
		GROUP BY ITEM_CD
	) 
	/* 월별 관리 시즌지수 생성 */	
	, SES_2 AS (
		SELECT ITEM_CD
			 , MM
			 , SES2
			 , CASE WHEN ROUND(SES2, 4) >= 2.5 THEN 1 ELSE 0 END OVER_STRONG
			 , CASE WHEN MM BETWEEN 1 AND 3 THEN 'Q1' 
				    WHEN MM BETWEEN 4 AND 6 THEN 'Q2'
				    WHEN MM BETWEEN 7 AND 9 THEN 'Q3'
				    ELSE 'Q4' END QUARTER
		  FROM (
				SELECT A.ITEM_CD
					 , MM
					 , CASE WHEN MY_SUM = 0 THEN 0 ELSE MY_AVG / MY_SUM * 12 END SES2
				FROM MY_AVG A
				INNER JOIN MY_SUM B ON A.ITEM_CD = B.ITEM_CD
				)
	) 
   SELECT RAWTOHEX(SYS_GUID()) AS ID
	    , p_VER_CD AS VER_CD
	    , A.ITEM_CD
		, NVL(MM1SES1, 0) AS MM1SES1
		, NVL(MM2SES1, 0) AS MM2SES1 
		, NVL(MM3SES1, 0) AS MM3SES1 
		, NVL(MM4SES1, 0) AS MM4SES1 
		, NVL(MM5SES1, 0) AS MM5SES1 
		, NVL(MM6SES1, 0) AS MM6SES1 
		, NVL(MM7SES1, 0) AS MM7SES1 
		, NVL(MM8SES1, 0) AS MM8SES1 
		, NVL(MM9SES1, 0) AS MM9SES1 
		, NVL(MM10SES1, 0) AS MM10SES1
		, NVL(MM11SES1, 0) AS MM11SES1
		, NVL(MM12SES1, 0) AS MM12SES1
		, NVL(MM1SES2, 0) AS MM1SES2
		, NVL(MM2SES2, 0) AS MM2SES2 
		, NVL(MM3SES2, 0) AS MM3SES2 
		, NVL(MM4SES2, 0) AS MM4SES2 
		, NVL(MM5SES2, 0) AS MM5SES2 
		, NVL(MM6SES2, 0) AS MM6SES2 
		, NVL(MM7SES2, 0) AS MM7SES2 
		, NVL(MM8SES2, 0) AS MM8SES2 
		, NVL(MM9SES2, 0) AS MM9SES2 
		, NVL(MM10SES2, 0) AS MM10SES2 
		, NVL(MM11SES2, 0) AS MM11SES2 
		, NVL(MM12SES2, 0) AS MM12SES2
		, CASE WHEN Q1_OVER_WEAK >= 1 THEN 1 ELSE 0 END Q1_OVER_WEAK
		, CASE WHEN Q2_OVER_WEAK >= 1 THEN 1 ELSE 0 END Q2_OVER_WEAK
		, CASE WHEN Q3_OVER_WEAK >= 1 THEN 1 ELSE 0 END Q3_OVER_WEAK
		, CASE WHEN Q4_OVER_WEAK >= 1 THEN 1 ELSE 0 END Q4_OVER_WEAK
		, CASE WHEN NVL(Q1_OVER_WEAK, 0) + NVL(Q2_OVER_WEAK, 0) + NVL(Q3_OVER_WEAK, 0) + NVL(Q4_OVER_WEAK, 0) >= 1 THEN 1 ELSE 0 END RES_WEAK
		, CASE WHEN Q1_OVER_STRONG >= 1 THEN 1 ELSE 0 END Q1_OVER_STRONG
		, CASE WHEN Q2_OVER_STRONG >= 1 THEN 1 ELSE 0 END Q2_OVER_STRONG
		, CASE WHEN Q3_OVER_STRONG >= 1 THEN 1 ELSE 0 END Q3_OVER_STRONG
		, CASE WHEN Q4_OVER_STRONG >= 1 THEN 1 ELSE 0 END Q4_OVER_STRONG
		, CASE WHEN NVL(Q1_OVER_STRONG, 0) + NVL(Q2_OVER_STRONG, 0) + NVL(Q3_OVER_STRONG, 0) + NVL(Q4_OVER_STRONG, 0) >= 1 THEN 1 ELSE 0 END RES_STRONG
		, 'SYSTEM' AS CREATE_BY
		, SYSDATE AS CREATE_DTTM
		, NULL AS MODIFY_BY
		, NULL AS MODIFY_DTTM		
		, p_WEAK AS CRITERIA_WEAK
		, p_STRONG AS CRITERIA_STRONG
	  FROM ( 
	  		SELECT ITEM_CD
	  			 , MM
	  			 , SES1
	  		  FROM SES_1
	  		)
			 PIVOT ( MAX(SES1) FOR MM IN ('1' AS MM1SES1, '2' AS MM2SES1, '3' AS MM3SES1, '4' AS MM4SES1, '5' AS MM5SES1, '6' AS MM6SES1
			 							, '7' AS MM7SES1, '8' AS MM8SES1, '9' AS MM9SES1, '10' AS MM10SES1, '11' AS MM11SES1, '12' AS MM12SES1) ) A
	 INNER JOIN 
		   ( 
		   	SELECT ITEM_CD
		   		 , MM
		   		 , SES2 
		      FROM SES_2
		   	)
			 PIVOT ( MAX(SES2) FOR MM IN ('1' AS MM1SES2, '2' AS MM2SES2, '3' AS MM3SES2, '4' AS MM4SES2, '5' AS MM5SES2, '6' AS MM6SES2
			 							, '7' AS MM7SES2, '8' AS MM8SES2, '9' AS MM9SES2, '10' AS MM10SES2, '11' AS MM11SES2, '12' AS MM12SES2) ) B
	 ON A.ITEM_CD = B.ITEM_CD
	 INNER JOIN 
	 	   (
	 		SELECT ITEM_CD
	 			 , QUARTER
	 			 , SUM(OVER_WEAK) AS OVER_WEAK
	 		FROM SES_1
	 		GROUP BY ITEM_CD, QUARTER
	 	   )
	 	   PIVOT ( SUM(OVER_WEAK) FOR QUARTER IN ('Q1' AS Q1_OVER_WEAK, 'Q2' AS Q2_OVER_WEAK, 'Q3' AS Q3_OVER_WEAK, 'Q4' AS Q4_OVER_WEAK) ) C
	 ON A.ITEM_CD = C.ITEM_CD
	 INNER JOIN 
	 	   (
	 		SELECT ITEM_CD
	 			 , QUARTER
	 			 , SUM(OVER_STRONG) AS OVER_STRONG
	 		FROM SES_2
	 		GROUP BY ITEM_CD, QUARTER
	 	   )
	 	   PIVOT ( SUM(OVER_STRONG) FOR QUARTER IN ('Q1' AS Q1_OVER_STRONG, 'Q2' AS Q2_OVER_STRONG, 'Q3' AS Q3_OVER_STRONG, 'Q4' AS Q4_OVER_STRONG) ) D
	 ON A.ITEM_CD = D.ITEM_CD	 
	;

	COMMIT;

--	P_RT_ROLLBACK_FLAG := 'true';
--  P_RT_MSG := 'MSG_0001';  --저장 되었습니다.

	EXCEPTION WHEN OTHERS THEN
		ROLLBACK;
	
		a := SQLCODE;
		b := SQLERRM;
		c := SYS.dbms_utility.format_error_backtrace;
	
		BEGIN
			INSERT INTO TB_SCM100M_ERR_LOG(ERR_FILE, ERR_CODE, ERR_MSG, ERR_LINE, ERR_DTTM)
			SELECT 'SP_UI_BF_00_SEASONAL_INDEX_M', a, b, c, SYSDATE FROM DUAL;
		
			COMMIT;
		END;         
END;